# 4类 JavaScript 内存泄漏

标签（空格分隔）： js

---

> 内存泄漏是每个开发者最终都要面对的问题，他是许多问题的根源： 反应迟缓，崩溃，高延迟，以及其他应用问题

## What?
本质上，内存泄漏可以定义为：应用程序不再需要占用内存的时候，由于某些原因，内存没有被操作系统或可用内存池回收。编程语言管理内存的方式各不相同。只有开发者最清楚哪些内存不需要了。操作系统可用回收。

## JavaScript 内存管理
JavaScript 是一种垃圾回收语言。垃圾回收语言通过周期性地检查先前分配的内存是否可达，帮助开发者管理内存。换言之，垃圾回收语言减轻了“内存仍可用”及“内存仍可达”的问题。两者的区别是微妙而重要的：仅有开发者了解哪些内存在将来仍会使用，而不可达内存通过算法确定和标记，适时被操作系统回收。

## Mark-and-sweep
大部分回收语言用的算法称之为 Mark-and-sweep: 

1. 垃圾回收器创建了一个“roots”列表。Roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root。window对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾）；
2. 所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾。
3. 所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。

现代的垃圾回收器改良了算法，但是本质是相同的：可达内存被标记，其余的被当作垃圾回收。
____
## 四种常见的JavaScript 内存泄漏

### 1. 意外的全局变量
```
function foo (arg) {
    // 相当于window.bar
    bar = "this is a hidden global variable";
}

function foo () {
    this.varialbe = "hefeng"
}
// this指向全局变量
foo()
```

全局变量注意事项：

尽管我们讨论了一些意外的全局变量，但是仍有一些明确的全局变量产生的垃圾。它们被定义为不可回收（除非定义为空或重新分配）。尤其当全局变量用于临时存储和处理大量信息时，需要多加小心。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。与全局变量相关的增加内存消耗的一个主因是缓存。缓存数据是为了重用，缓存必须有一个大小上限才有用。高内存消耗导致缓存突破上限，因为缓存内容无法被回收。

### 2. 被遗忘的计时器或回调函数
```
var someResoure = getData()

setInterval(function() {
    var node = document.getElementById('Node');
    if(node) {
        node.innerHTML = JSON.stringify(someResource)
    }
}, 1000)
```

此例说明了什么：与节点或数据关联的计时器不再需要，node对象可以删除，整个回调函数也不需要。可是，计时器回调函数仍然没被回收（计时器停止才会回收）。同时 someResource 如果存储了大量的数据，也是无法回收的。

### 3. 脱离DOM的引用
有时，保存DOM节点内部数据结构很有用。假如你想快速更新表格的几行内容，把每一行 DOM 存成字典（JSON 键值对）或者数组很有意义。此时，同样的DOM元素存在两个引用：一个在DOM树中，另一个在字典中。将来你决定删除这些行时，需要把两个引用都清除。

    var elements = {
        button: document.getElementById('button')
        image: document.getElementById('image')
    }

此外还要考虑 DOM 树内部或子节点的引用问题。假如你的 JavaScript 代码中保存了表格某一个 <td> 的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的 <td> 以外的其它节点。实际情况并非如此：此 <td> 是表格的子节点，子元素与父元素是引用关系。由于代码保留了 <td> 的引用，导致整个表格仍待在内存中。保存 DOM 元素引用的时候，要小心谨慎。

### 4. 闭包
闭包保存着私有变量和父函数，当重复调用时，将会有多份数据保存。造成很大的内存泄漏。