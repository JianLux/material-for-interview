# this绑定机制

标签（空格分隔）： js

---

## 默认绑定

在非严格模式下，默认绑定的this指向全局对象，严格模式下this指向undefined

## 隐式绑定

函数在调用位置，是否有上下文对象，如果有，那么this就会隐式绑定到这个对象上

```
    function foo() {
      console.log(this.a);
    }
    var a = "Oops, global";
    let obj2 = {
      a: 2,
      foo: foo
    };
    let obj1 = {
      a: 22,
      obj2: obj2
    };
    obj2.foo(); // 2 this指向调用函数的对象
    obj1.obj2.foo(); // 2 this指向最后一层调用函数的对象
    
    // 隐式绑定丢失
    let bar = obj2.foo; // bar只是一个函数别名 是obj2.foo的一个引用
    bar(); // "Oops, global" - 指向全局

```

### 隐式丢失

隐式绑定丢失的问题：实际上就是函数调用时，并没有上下文对象，只是对函数的引用，所以会导致隐式绑定丢失

 > 可以考虑函数的调用
 
 
## 显示绑定
 
 就像我们上面看到的，如果单纯使用隐式绑定肯定没有办法得到期望的绑定，幸好我们还可以在某个对象上强制调用函数，从而将this绑定在这个对象上。
 
 我们可以通过apply、call、bind将函数中的this绑定到指定对象上。
 
 我们可以通过apply、call、bind将函数中的this绑定到指定对象上。

传入的不是对象：

如果你传入了一个原始值(字符串,布尔类型，数字类型)，来当做this的绑定对象，这个原始值转换成它的对象形式。

如果你把null或者undefined作为this的绑定对象传入call/apply/bind，这些值会在调用时被忽略，实际应用的是默认绑定规则。

## new绑定

使用构造调用的时候，this会自动绑定在new期间创建的对象上。

new的时候会做哪些事情：

1. 创建一个全新的对象。
2. 这个新对象会被执行 [[Prototype]] 连接。
3. 这个新对象会绑定到函数调用的this。
4. 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象

## 优先级

显式绑定 > 隐式绑定 > 默认绑定

new绑定 > 隐式绑定 > 默认绑定

## 箭头函数this

> 箭头函数中的this继承于它外面第一个不是箭头函数的函数的this指向。
> 箭头函数的 this 一旦绑定了上下文，就不会被任何代码改变。